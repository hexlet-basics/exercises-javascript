---

name: Слабая типизация — 2
theory: |

  В модуле «Арифметика» мы затронули тему слабой типизации.

  JavaScript — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется ему разумным.

  Особенно много автоматических преобразований происходит при работе с логическими операциями.

  Пример:

  ```javascript
  console.log(0 || 1);
  ```

  <pre class='hexlet-basics-output'>1</pre>

  Что тут произошло:

  Оператор **ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `true`.

  Пример:

  ```javascript
  console.log(0 && 1);
  ```

  <pre class='hexlet-basics-output'>0</pre>

  Что тут произошло:

  Оператор **И** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `false`.

  В JavaScript есть два простых правила, по которым происходят преобразования:

  * `0`, `''`, `undefined`, `NaN`, `null` приводятся к `false`. Эти значения называют *falsy*.
  * Всё остальное приводится к `true`

  Этим активно пользуются в разработке, например, для определения значения по умолчанию:

  ```javascript
  const value = name || '';
  // Примеры
  234 || ''; // 234
  'hexlet' || ''; // 'hexlet'
  ```

  Но здесь есть потенциальный баг. Если `name` может содержать falsy значения и это допустимо, то код выше начнет работать неверно:

  ```javascript
  // Упс
  false || ''; // ''
  0 || ''; // ''
  undefined || ''; // ''
  ```

  В одном из уроков мы рассмотрели операторы сравнения `===` и `!==` и упомянули, что в JavaScript так же есть операторы `==` и `!=`, но их не стоит использовать. Отличия как раз заключаются в преобразовании типов:

  ```javascript
  console.log('' === false); // => false
  console.log('' == false);  // => true
  ```

  Пустая строка и `false` — это разные значения, поэтому оператор `===` говорит «ложь! они не равны!».

  Но оператор `==` преобразует типы, и с его точки зрения пустая строка и `false` равны.

  Это преобразование неявное, поэтому по возможности избегайте операторов `==` и `!=`.

  ---

  Вспомните операцию отрицания:

  ```javascript
  const answer = true;
  console.log(!answer); // => false
  ```

  При двойном отрицании `!!` итоговое значение равно начальному:

  ```javascript
  const answer = true;
  console.log(!!answer); // => true
  ```

  Но здесь дополнительно происходят преобразования типа. Поэтому результатом двойного отрицания всегда будет значение типа _boolean_. Этим приемом иногда пользуются, чтобы поменять тип данных.

instructions: |

  Реализуйте функцию `getLetter()`, которая извлекает из переданной строки указанный символ (по порядковому номеру, а не индексу) и возвращает его наружу. Если такого символа нет, то функция возвращает пустую строку.

  Примеры вызова:

  ```javascript
  const name = 'Hexlet';

  // Обычное обращение возвращает undefined
  name[10]; // undefined

  // 11 символ соответствует 10 индексу
  getLetter(name, 11); // ''

  getLetter(name, 1); // 'H'
  getLetter(name, 0); // ''
  getLetter(name, 6); // 't'
  ```

tips:
  - |
    [Boolean](https://ru.wikipedia.org/wiki/Логический_тип)
  - |
    [Извлечение символов из строки](https://ru.code-basics.com/languages/javascript/modules/variables/lessons/symbols)
