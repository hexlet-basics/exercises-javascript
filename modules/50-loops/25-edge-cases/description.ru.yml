---

name: Пограничные случаи
theory: |

  Функция `mysubstr`, которую вы реализовали в прошлом уроке, содержит множество ошибок. «Но ведь она прошла проверки!». Да, но в этих проверках не было так называемых **пограничных случаев**. Функция нормально работала с нормальными аргументами, но как она поведет себя, если передать ей такие варианты длины?

  * `0`
  * Отрицательное число
  * Число, превышающее реальный размер строки

  Функция `mysubstr` не рассчитана на такие варианты. Можно подумать, что это не проблема: функция работает в нормальных условиях, и просто не нужно передавать ей «плохие» аргументы. В идеальном мире — да, но в реальном мире ваш код будет запускаться в разных ситуациях, с разными комбинациями условий и данных. Нельзя быть уверенным, что аргументы всегда будут корректными, поэтому нужно учитывать все случаи, в рамках здравого смысла.

  Ошибки в пограничных случаях — самая частая причина логических ошибок в программах. Программисты всегда забывают что-нибудь учесть. Такие ошибки часто проявляются не сразу, и могут долгое время не приводить к видимым проблемам. Программа продолжает работать, но в какой-то момент обнаруживается, что в результатах есть ошибки. Часто причина в слабой типизации JavaScript.

  Умение справляться с такими ошибками приходит с опытом, через постоянные косяки в стиле «ой, забыл проверить на пустую строку!».

  ---

  Давайте представим себе расширенную функцию `mysubstr`. Она принимает три аргумента: строку, индекс и длину извлекаемой подстроки. Функция возвращает подстроку указанной длины начиная с указанного индекса. Примеры вызова:

  ```javascript
  str = 'If I look back I am lost';
  mysubstr(str, 0, 1); // 'I'
  mysubstr(str, 3, 6); // 'I look'
  ```

  Прикинем, что может пойти не так. Какие **пограничные случаи** стоит учитывать:

  * Отрицательная длина извлекаемой подстроки
  * Отрицательный заданный индекс
  * Заданный индекс выходит за границу всей строки
  * Длина подстроки в сумме с заданным индексом выходит за границу всей строки

  В реализации функции каждый пограничный случай будет отдельным куском кода, скорее всего реализованным с помощью `if`.

  Чтобы написать функцию `mysubstr` и защититься от этих случаев, стоит написать отдельную функцию, которая будет проверять аргументы на корректность. Займемся этим в задании.

instructions: |

  Реализуйте функцию-предикат `isArgumentsForSubstrCorrect`, которая принимает три аргумента:

  1. строку
  2. индекс, с которого начинать извлечение
  3. длину извлекаемой подстроки

  Функция возвращает `false`, если хотя бы одно из условий истинно:

  * Отрицательная длина извлекаемой подстроки
  * Отрицательный заданный индекс
  * Заданный индекс выходит за границу всей строки
  * Длина подстроки в сумме с заданным индексом выходит за границу всей строки

  В ином случае функция возвращает `true`.

  Не забывайте, что индексы начинаются с `0`, поэтому индекс последнего элемента — это «длина строки минус 1».

  Пример вызова:

  ```javascript
  const str = 'Sansa Stark';
  isArgumentsForSubstrCorrect(str, -1, 3);  // false
  isArgumentsForSubstrCorrect(str, 4, 100); // false
  isArgumentsForSubstrCorrect(str, 10, 10); // false
  isArgumentsForSubstrCorrect(str, 11, 1);  // false
  isArgumentsForSubstrCorrect(str, 3, 3);   // true
  isArgumentsForSubstrCorrect(str, 0, 5);   // true
  ```

tips: []
