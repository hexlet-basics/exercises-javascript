---

name: Data aggregation (numbers)
theory: |
  
  A distinct class of problems where loops are indispensable is called data aggregation. Such problems include searching for the maximum, minimum, sum, arithmetic mean, etc. Their main feature is that their result depends on the whole data set. To calculate the sum, you have to add **all** numbers and to calculate the maximum you have to compare **all** numbers.

  Anyone dealing with numbers, such as accountants or marketers, is familiar with these tasks. Usually, a spreadsheet like Microsoft Excel or Google Tables does it.

  Consider a trivial example: the sum of a number set. We will implement a function adding numbers in a given range, including bounds. Here we have a range of numbers from a least (lower bound) to a greatest (upper bound). For example, the range [1, 10] includes all integers from 1 to 10.

  ```javascript
  sumNumbersFromRange(5, 7); // 5 + 6 + 7 = 18
  sumNumbersFromRange(1, 2); // 1 + 2 = 3

  // The range [1, 1] is also a range
  // it includes just one number — the bound of the range itself
  sumNumbersFromRange(1, 1); // 1
  sumNumbersFromRange(100, 100); // 100
  ```

  To implement this function we need a loop because adding numbers is an iterative process (an iteration for each number), and the number of iterations depends on the size of the range. Before looking at the code, try answering the questions below:

  * Which value you will set the counter with?
  * How it will change?
  * When the loop should stop?

  Try think through these questions first and then get a look at the code below:

  ```javascript
  const sumNumbersFromRange = (start, finish) => {
    // You can, of course, change the 'start' value
    // But the input arguments must be unchanged
    // It makes the code easier to analyze
    let i = start;
    let sum = 0; // Sum initialization

    while (i <= finish) { // Move to the end of the range
      sum = sum + i; // Calculate sum for each number
      i = i + 1; // Go to the next number in the range
    }

    // Return loop result
    return sum;
  };
  ```

  We have a standard general structure of the loop here. A counter initialized with a start value of the range, a loop with a condition to stop at the end of the range and, finally, a counter change at the end of the loop's body. The number of iterations in such a loop is `finish - start + 1`. Thus, for the range from 5 to 7, it is 7 - 5 + 1, or three iterations.

  The main difference from regular processing is related to the logic of computing the result. In aggregation tasks, there is always some variable that stores a result of the loop. In the code above, it is `sum`. At each loop iteration, this variable changes and adds another number from the range: `sum = sum + i`. The whole process looks like this:

  ```javascript
  // Calling sumNumbersFromRange(2, 5);
  let sum = 0;
  sum = sum + 2; // 2
  sum = sum + 3; // 5
  sum = sum + 4; // 9
  sum = sum + 5; // 14
  // 14 – the result of adding the numbers in the range [2, 5]
  ```

  The `sum` variable has an initial value of 0. Why do you need to set the value at all? Any iterative operation starts with some value. You can't just declare an empty variable and start working with it within a loop. It will lead to the wrong result:

  ```javascript
  // when there is no initial value
  // js sets it to undefined
  let sum;

  // first iteration
  sum = sum + 2; // ?
  ```

  It will result in `NaN`, i.e. not a number, inside `sum`. It occurs due to an attempt to add `2` and `undefined`. So you should have some initial value. Why is 0 chosen in the code above? Well, it is easy to check that all the other options would lead to the wrong result. If the initial value is 1, the sum will be 1 more than it should be.

  In mathematics there is a notion of **identity (or neutral) element** (an element for each type of operation). Its meaning is easy to grasp. An operation with this element doesn't change the second operand of operation. For an addition, any number plus zero results in the number itself. The same goes for subtraction. Even concatenation has a neutral element, which is an empty string: `'' + 'one'` will be 'one'.

  Quick self-check. What is the neutral element of the multiplication?

instructions: |

  Write a function `multiplyNumbersFromRange()` that multiplies numbers in a given range, including its bounds. An example:

  ```javascript
  multiplyNumbersFromRange(1, 5); // 1 * 2 * 3 * 4 * 5 = 120
  multiplyNumbersFromRange(2, 3); // 2 * 3 = 6
  multiplyNumbersFromRange(6, 6); // 6
  ```

tips: []
