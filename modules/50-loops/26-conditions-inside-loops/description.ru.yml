---

name: Условия внутри тела цикла
theory: |

  Тело цикла как и тело функции это место выполнения инструкций. А значит мы можем использовать внутри него все изученное ранее, например условные конструкции.

  Представьте себе функцию, которая считает сколько раз входит буква в предложение. Пример ее работы:

  ```javascript
  countChars('Fear cuts deeper than swords.', 'e'); // 4
  // Если ничего не нашли, то значит результат 0 совпадений
  countChars('Sansa', 'y'); // 0
  ```

  Перед тем как посмотреть ее содержимое, попробуйте ответить на вопросы:

  * Является ли эта операция агрегацией?
  * Какой будет проверка на вхождение символа?

  ```javascript
  const countChars = (str, char) => {
    let i = 0;
    let count = 0;
    while (i < str.length) {
      if (str[i] === char) {
        // Считаем только подходящие символы
        count = count + 1;
      }
      // Счетчик увеличивается в любом случае
      i = i + 1;
    }

    return count;
  };
  ```

  Эта задача является агрегирующей. Несмотря на то, что она считает не все символы, для подсчета самой суммы все равно приходится анализировать каждый символ.

  Ключевое отличие этого цикла от рассмотренных в наличии условия внутри тела. Переменная `count` увеличивается только в том случае, когда текущий рассматриваемый символ совпадает с ожидаемым.

  В остальном это типичная агрегатная функция, которая возвращает количество нужных символов вызываемому коду.

instructions: |

  Функция из теории учитывает регистр букв. То есть `A` и `a` с ее точки зрения разные символы. Реализуйте вариант этой же функции, так чтобы регистр букв был не важен:

  ```javascript
  countChars('HexlEt', 'e'); // 2
  countChars('HexlEt', 'E'); // 2
  ```

tips: []
